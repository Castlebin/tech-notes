## 事务隔离

简单来说，事务就是要**保证一组数据库操作，要么全部成功，要么全部失败**。在 MySQL 中，事务支持是在**引擎层**实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一。  

以 InnoDB 为例，剖析 MySQL 在事务支持方面的特定实现  

### 隔离性与隔离级别

当数据库上有多个事务同时执行的时候，就可能出现**脏读（dirty read）**、**不可重复读（non-repeatable read）**、**幻读（phantom read）**的问题，为了解决这些问题，就有了“隔离级别”的概念。在谈隔离级别之前，你首先要知道，你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：**读未提交（read uncommitted）**、**读提交（read committed）**、**可重复读（repeatable read）**和**串行化（serializable）**。下面我逐一为你解释：

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
- 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
- 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

在实现上，数据库里会创建一个**视图**，访问的时候，以视图的逻辑结果为准。

在**可重复读**隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都使用这个视图。

在**读提交**隔离级别下，这个视图是在每个 SQL 开始执行时创建的

这里要注意的是，**读未提交**隔离级别直接返回记录的最新值，不存在视图的概念；而**串行化**隔离级别下直接采用了加锁的方式来避免并行访问。

Oracle 数据库的默认隔离级别其实就是“读提交”，而 MySQL 是“可重复读”，因此对于一些从 Oracle 迁移到 MySQL 的应用，为保证数据库隔离级别的一致，你一定要记得将 MySQL 的隔离级别设置为“读提交”。  

## 事务隔离的实现

理解了事务的隔离级别，我们再来看看事务隔离具体是怎么实现的。这里我们展开说明**“可重复读”**。  

在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。  

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。

<img src="pic/read_view.png" title="MySQL 视图" style="width:70%">

当前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。  

你一定会问，回滚日志总不能一直保留吧，什么时候删除呢？  

答案是，在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。什么时候才不需要了呢？就是**当系统里没有比这个回滚日志更早的 read-view 的时候**。  

基于上面的说明，我们来讨论一下为什么建议你**尽量不要使用长事务**。  

长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

除了对回滚段的影响，长事务还**占用锁资源**，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。

### 事务的启动方式

事务的启动方式如前面所述，长事务有这些潜在风险，我当然是建议你尽量避免。其实很多时候业务开发同学并不是有意使用长事务，通常是由于误用所致。MySQL 的事务启动方式有以下几种：  

1. 显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。
2. set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。   

有些客户端连接框架会默认连接成功后先执行一个 set autocommit=0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。

因此建议总是使用 设置 autocommit=1。通过显式语句的方式来启动事务

 

使用 commit work and chain，可以提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。



### 两种方式启动一个事务的差别

```SQL
-- 1. 显式启动事务
begin;
-- 或者
start transaction;  -- 注意！执行了这两句之后，只有**开始执行第一条SQL语句时，事务才正式开启，一致性视图   												从这个时候创建**

-- 2. 或者
start transaction with consistent snapshot;   -- 这个命令立即开始事务并且创建一个read view
```



**`begin`或 `start transaction` 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 `start transaction with consistent snapshot` 这个命令。**

第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；

第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。

