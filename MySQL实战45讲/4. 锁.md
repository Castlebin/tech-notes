## MySQL 中锁的分类

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类：

### 1. 全局锁

顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一种加全局锁的方法，命令是 `FLUSH TABLES WITH READ LOCK;`  (FTWRL)，执行之后，整个库处于只读状态，任何涉及变更的操作都将被阻塞。

全局锁的典型使用场景是做数据库的**全库逻辑备份**。使得备份的数据能够处于同一个逻辑时间点。

同样能实现这个目的的方法是在可重复读隔离级别下，启动一个事务，这样在事务启动时，将创建一个逻辑视图，备份数据能够拿到一个一致视图。MySQL 官方的备份工具 mysqldump ，使用参数 `–single-transaction` 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而且由于 MVCC 的支持，这个过程中数据是可以正常更新的。

既然如此，为什么需要全局锁？  

原因在于，一致性视图很好，但**不是所有的数据库引擎都支持这个隔离级别**。比如 MyISAM 就不支持。所以，-single-transaction 方法只适用于所有的表使用事务引擎的库。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。  

对于支持一致性视图的引擎来说，做备份，  -single-transaction 方式确实更友好。  

FTWRL 使用 `UNLOCK TABLES;` 命令来释放锁。

### 2. 表级锁

1. 表锁  **表锁的语法是 lock tables … read/write**。 与 FTWRL 类似，可以用 `unlock tables` 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。  

   举个例子, 如果在某个线程 A 中执行 `lock tables t1 read, t2 write;` 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表。

2. 元数据锁（MDL） **MDL 不需要显式使用，在访问一个表的时候会被自动加上**。在 MySQL 5.5 版本中引入的 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁  

   读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。  

   读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。  
   
   我们知道，给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。在对大表操作的时候，你肯定会特别小心，以免对线上服务造成影响。而实际上，即使是小表，操作不慎也会出问题。我们来看一下下面的操作序列，假设表 t 是一个小表。备注：这里的实验环境是 MySQL 5.6。
   
   <img src="pic/MDL_lock.jpg" title="给表加字段被阻塞" style="width:70%">
   
   1. 我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。由于 session B 需要的也是 MDL 读锁，因此可以正常执行。   
   2. 之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。
   3. 如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。前面我们说了，所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住，等于这个表现在完全不可读写了。如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。
   
   你现在应该知道了，事务中的 MDL 锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。所以，必须 **session A 事务提交之后**，session C 以及后面的操作才能正常进行 。
   
   **这里比较难以理解的是，为什么 session D 也会阻塞？** 原因是：MySQL 对于session C，D **有一个锁 队列 来决定谁先执行**（作者回复: 如果说设计初衷，是为了防饿死吧）
   
   AliSQL 提供了一个功能，可以在alter table时做一定时间的等待，这样，即使被阻塞，一段时间后，它会失败，这样也不会影响后续的操作。MariaDB 也已经合并了这个功能。语句如下，`WAIT N`
   
   ```SQL
   ALTER TABLE tbl_name NOWAIT add column ...
   ALTER TABLE tbl_name WAIT N add column ... 
   ```

3. 意向锁？   这个没讲，按作者的话是，有了**MDL 锁**，暂时可以不用管

一些好的问题和作者回复：

1. 全局锁和表锁是 Server 层实现的吗？     是

2. 例子里为什么session C之后的所有“读”请求都会被阻塞？毕竟session C还没加上锁。难道这里隐含涉及到了意向锁？

   ```
   这个不是读写锁，是锁队列，一进去就开始影响后面的
   ```

3. 老师，意向锁是表锁吗？与MDL锁主要区别是什么呢？

   ```
   意向锁是表级锁，是实现在Innodb 的。
   有了mdl表锁，你可以暂时先不管意向锁了😄
   ```

   

### 3. 行锁

读完本章，我的一个观点：**InnoDB 的行锁 可以说是 MySQL 中最重要的一种锁了**

MySQL 的行锁是在**引擎层由各个引擎自己实现的**。所以并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。  

不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

顾名思义，行锁就是针对数据表中行记录的锁。这很好理解，比如事务 A 更新了一行，而这时候事务 B 也要更新同一行，则必须等事务 A 的操作完成后才能进行更新。  

#### 两阶段锁协议

举个例子。在下面的操作序列中，事务 B 的 update 语句执行时会是什么现象呢？假设字段 id 是表 t 的主键

<img src="pic/two_phase_lock.jpg" title="加锁" style="width:60%">

这个问题的结论取决于事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务 B 的 update 语句会被阻塞，直到**事务 A 执行 commit 之后，事务 B 才能继续执行**。  

知道了这个答案，你一定知道了事务 A 持有的两个记录的行锁，都是在** commit 的时候才释放的**。  

也就是说，**在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。  **

知道了这个设定，对我们使用事务有什么帮助呢？那就是，**如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放**。  



InnoDB存储引擎实现了如下两种标准的行级锁：  

1. 共享锁（S Lock）：允许事务读一行数据  
2. 排他锁（X Lock）：允许事务删除或更新一行数据  
   SS相互兼容：T1事务获取了r行的共享锁，那么T2事务也可以获取行r的共享锁   

XX、XS、SX不兼容：  

- T1事务获取了r行的共享锁，T2事务不能获取排他锁  
- T1事务获取了r行的排他锁，T2事务不能获取共享锁或者排他锁  

> select语句默认不会加任何锁类型，如果想加排他锁可以使用select for update；想加共享锁使用select lock in share mode
> update、delete、insert都会自动给涉及到的数据加上排他锁

#### 死锁和死锁检测

