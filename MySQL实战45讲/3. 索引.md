## 索引的常见模型

索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。  

可以用于提高读写效率的数据结构很多，三种常见、也比较简单的数据结构，它们分别是**哈希表、有序数组 和 搜索树**。  另外，**跳表、LSM 树** 也是现代数据库引擎中常见的索引模型了。  

数据库底层存储的核心就是基于这些数据模型的。**每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景**，分析问题也需要在脑海里建立模型的概念  

## InnoDB 索引模型

InnoDB 采用 B+ 树来实现索引结构，它是一颗 N 叉树，具体的要取决于索引长度和页大小，一般页大小为16K。对于一个整型字段索引，这个 N 大概是 1200。对于一个树高为 4 的索引树，能存下 1200<sup>3</sup> 的数据， 17 亿多。

考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

InnoDB 索引主要分两类，**主键索引**和**非主键索引**  

主键索引 的叶子节点存放的是整行数据（的**页**，注意，MySQL树节点上的数据都是按**页**为单位进行操作的），在 InnoDB 中，主键索引也称为 聚簇索引（clustered index）。  （因为索引和数据放在同一颗树上，所以称为聚簇索引）

非主键索引 的叶子节点存放的是主键的值，在 InnoDB 中，非主键索引也称为 二级索引（secondary index）。  

**注意**：B+ 树的每个子节点存放的都是**一页数据**，数据组织单位为**页（page）**，对于叶节点同样如此，主键索引的叶节点包含多行数据，非主键索引的叶节点包含多个数据的主键。page 内部是 有序数组，采用二分法定位数据。

查询时使用非主键索引命中时，得到 主键的值，根据主键的值，再去主键索引中查询出数据，这个多出来的步骤称为**回表**。也就是使用非主键索引时，需要再多扫描一棵索引树   

### 索引维护

- 页分裂

- 页合并

显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。  

所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。



问题：采用删除再重新指定索引的方式重新建立主键索引和非主键索引有什么不一样？两个操作都可以吗？

【回答】

1. 直接删掉主键索引是不好的（**不论是删除主键还是创建主键，都会将整个表重建，想想为什么？**），它会使得所有的二级索引都失效，并且会用ROWID来作主键索引；

2. 看到 MySQL 官方文档写了三种措施，第一个是整个数据库迁移，先dump出来再重建表（这个一般只适合离线的业务来做）；第二个是用**空的alter操作**，比如 **ALTER TABLE t1 ENGINE = InnoDB;** 这样子就会原地重建表结构；第三个是用repaire table，不过这个是由存储引擎决定支不支持的（InnoDB 就不行）



### 覆盖索引

如果在查询中，搜索结果已经“覆盖了”我们的查询需求，不需要回表，那我们称为**覆盖索引**  

覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。  

以一个市民信息表为例，假设，这个表里包含了市民的身份证号、名字、年龄等各种信息，那么是否有必要建立一个（身份证号, 名字）的联合索引？

我们知道，身份证号是唯一的，根据身份证号码查询用户信息是个很常见的需求，所以身份证号码字段上有索引是必须的。建立（身份证号, 名字）索引需要占用额外的磁盘空间。

如果现在有一个高频需求，那就是根据用户的身份证号，查询名字，那么建立这个联合索引就有意义了，因为它可以使这个高频请求上用到覆盖索引，不用回表查整行记录，减少了语句执行时间。

### 最左前缀原则

B+ 树这种数据结构，可以利用索引的“最左前缀”，来定位记录。

最左前缀原则有两点：

1. 对于一个字段，模糊查询时，对这个字段，遵循左匹配原则
2. 对于多个字段的查询，执行引擎也会按字段，尝试从左到右字段顺序进行匹配。因此，建立**联合索引**时，经常需要考虑字段顺序，这个需要根据业务逻辑进行安排，考虑索引的复用。第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的

### 索引下推

MySQL 5.6 引入的**索引下推优化（index condition pushdown)**， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数  

以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：

``` SQL
select * from T where name like '张%' and age=10 and ismale=1;
```

无索引下推优化 的执行流程

<img src="pic/no_index_pushdown.jpg" title="无索引下推优化" style="width:70%">



索引下推优化 的执行流程

<img src="pic/index_pushdown.jpg" title="索引下推优化" style="width:70%">



区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。



## 实践问题

1. 普通索引和唯一索引怎么选？

   先说对于查找，普通索引比唯一索引会多一次判断，但**由于数据以页为单位加载到内存中**，所以效率上影响微乎其微，可以视为一样  

   对于插入，唯一索引不能利用到 **Change Buffer** ，效率上会差一些

   对于更新，**如果更新操作会涉及到影响唯一键**，那么不能利用到 **Change Buffer**（插入其实是一个道理），效率会差一些  

   结论：唯一索引的更新，不能利用到 Change Buffer，效率上会差一些，确实也**只有普通索引能够用到**（主键索引是一种唯一索引，所以也不能用到）  



如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。  （想想为什么？）

2. 如果某次写入使用了 change buffer 机制，之后主机异常重启，是否会丢失 change buffer 和数据？  

   答案：不会丢失。虽然是只更新内存，但是在事务提交的时候，我们把 **change buffer 的操作也记录到 redo log 里了，所以崩溃恢复的时候，change buffer 也能找回来**。


3. 下面这个建表语句中 三个索引 c、ca、cb都是必要的吗？

```mysql
CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

答案：  ca 是不需要的，因为：InnoDB会把主键字段放到索引定义字段后面，当然同时也会去重。

所以，当主键是(a,b)的时候，
**定义为c的索引，实际上是（c,a,b);
定义为(c,a)的索引，实际上是(c,a,b) **

ps 定义为(c,b）的索引，实际上是（c,b,a)





